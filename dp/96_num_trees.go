package dp

// 递推公式：dp[i]：1到i为节点组成的二叉搜索树的个数
// dp[i] += dp[j - 1] * dp[i - j] 表示
// dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
func numTrees(n int) int {
	dp := make([]int, n + 1)
	dp[0] = 1
	for i := 1; i <= n; i++ {
		for j := 1; j <= i; j++ {
			dp[i] += dp[j - 1] * dp[i - j]
		}
	}
	return dp[n]
}


//dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
//
//元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
//
//元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
//
//元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
//
//有2个元素的搜索树数量就是dp[2]。
//
//有1个元素的搜索树数量就是dp[1]。
//
//有0个元素的搜索树数量就是dp[0]。
//
//所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
//
// j <= i
// dp[i] += dp[j - 1] * dp[i - j]